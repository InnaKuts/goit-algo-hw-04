# Домашнє завдання 4

## Вступ
- **Insertion Sort**: простий алгоритм сортування, ефективний на невеликих масивах або на вже відсортованих даних, із часовою складністю O(n²) у загальному випадку.
- **Merge Sort**: алгоритм "розділяй і володарюй" із гарантованою часовою складністю O(n log n), незалежно від впорядкованості вхідних даних.
- **Timsort**: гібридний алгоритм, який поєднує сортування злиттям і вставками, що дозволяє ефективно обробляти як впорядковані, так і невпорядковані дані.

## Емпіричні дані
Нижче наведена таблиця, що представляє результати вимірювання часу виконання трьох алгоритмів сортування на різних наборах даних. Дані у таблиці — це **сумарний час виконання для 10 повторень** кожного алгоритму:

| Dataset            | Insertion Sort (сек) | Merge Sort (сек) | Timsort (`sorted()`) (сек) |
|--------------------|----------------------|------------------|----------------------------|
| Small Random       | 0.00005486           | 0.00018204       | 0.00000535                 |
| Medium Random      | 0.35865883           | 0.04437270       | 0.00086704                 |
| Small Sorted       | 0.00002222           | 0.00014550       | 0.00000407                 |
| Medium Sorted      | 0.00168183           | 0.03945723       | 0.00013526                 |
| Large Random       | -                    | 61.74331055      | 1.03348335                 |
| Large Sorted       | 1.65706534           | 48.31764787      | 0.16114353                 |

## Аналіз результатів
Порівняльний аналіз часу виконання алгоритмів показує такі ключові моменти:

1. **Small Random (10 елементів)**:
   - Алгоритми вставок (Insertion Sort) та злиття (Merge Sort) мають схожий час виконання, але Timsort (через `sorted()`) є найшвидшим завдяки оптимізації для малих масивів.

2. **Medium Random (1000 елементів)**:
   - Алгоритм вставок значно поступається за часом виконання, оскільки його складність O(n²) робить його неефективним для більших масивів.
   - Сортування злиттям займає кілька десятків мілісекунд, тоді як Timsort є значно швидшим.

3. **Small Sorted (10 елементів)**:
   - Для вже відсортованих даних алгоритм вставок показує дуже швидке виконання, але Timsort все ще перевершує його завдяки оптимізації для відсортованих масивів.

4. **Medium Sorted (1000 елементів)**:
   - Алгоритм вставок є ефективнішим порівняно з випадком невідсортованих даних, але Timsort і тут швидший завдяки вбудованій оптимізації для впорядкованих даних.

5. **Large Random (1 000 000 елементів)**:
   - Алгоритм вставок не використовувався через високу складність (O(n²)), яка робить його надто повільним для великих масивів.
   - Сортування злиттям потребує понад 60 секунд, тоді як Timsort упорався менш ніж за 2 секунди, що підтверджує його ефективність.

6. **Large Sorted (1 000 000 елементів)**:
   - Алгоритм вставок показує кращі результати для вже відсортованих даних, але все одно поступається Timsort.
   - Сортування злиттям виявилося найповільнішим серед алгоритмів.

### Висновки
На основі експериментальних даних можна зробити такі висновки:

1. **Час виконання**: Timsort значно випереджає алгоритми злиттям і вставками, особливо на великих масивах та для вже впорядкованих даних.
2. **Ефективність алгоритмів**: Алгоритм вставок є ефективним лише для малих або частково впорядкованих масивів, тоді як алгоритм злиття забезпечує стабільний час виконання незалежно від вхідних даних, але часто поступається Timsort.
3. **Поєднання вставок і злиття**: Саме поєднання цих двох підходів робить Timsort швидким і універсальним. Timsort використовує алгоритм вставок для невеликих масивів і злиття для більших сегментів, тим самим оптимізуючи час виконання.
